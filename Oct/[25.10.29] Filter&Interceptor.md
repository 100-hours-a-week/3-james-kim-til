# Filter & Interceptor in Spring
웹 애플리케이션에서 공통적인 보안, 로깅, 인증 등의 기능은 **모든 요청(Request)** 에 공통적으로 적용되어야 한다.  
이를 위해 자바 표준에서는 **Filter**, 스프링 MVC에서는 **Interceptor**를 제공한다.

---

## 1️⃣ Filter (서블릿 기반 수문장)

### 개념
`Filter`는 **서블릿(Controller 진입 전)** 에서 요청과 응답을 가로채 공통 로직을 처리하는 컴포넌트다.  
즉, 모든 요청을 **WAS 단계에서 전역적으로 제어**할 수 있다.

---

### 필터의 흐름

> HTTP Request → WAS → **Filter** → Servlet → Controller

---

### 제한 예시

```text
HTTP Request → WAS → Filter → Servlet → Controller (로그인 사용자)  
HTTP Request → WAS → Filter (적절하지 않은 요청 → 서블릿 호출X - 비 로그인 사용자)
```

---

### 🔗 필터 체인 동작
여러 개의 필터를 등록하면 순차적으로 체인 형태로 호출된다.

> HTTP Request → WAS → Filter1 → Filter2 → Filter3 → Servlet → Controller

---

### Filter 인터페이스 구조
```java
public interface Filter {
    default void init(FilterConfig filterConfig) throws ServletException {}
    
    void doFilter(ServletRequest request,
                  ServletResponse response,
                  FilterChain chain
                 ) throws IOException, ServletException;

    default void destroy() {}
}
```
- `init()` : 필터 초기화 (서블릿 컨테이너 시작 시 1회 호출)
- `doFilter()` : 요청마다 호출, 주 로직 담당
- `destroy()` : 종료 시 1회 호출

--- 

### 주요 용도
- 요청/응답 로깅
- 인코딩 설정
- CORS 처리
- 인증/인가, XSS 필터링
- 전역 공통 정책 (모든 URL 공통 로직)

### Spring Boot에서의 사용
스프링부트에서는 `FilterRegistrationBean`으로 필터를 빈으로 등록할 수 있다.
```java
@Bean
public FilterRegistrationBean<CustomFilter> loggingFilter() {
    FilterRegistrationBean<CustomFilter> registrationBean = new FilterRegistrationBean<>();
    registrationBean.setFilter(new CustomFilter());
    registrationBean.addUrlPatterns("/*");
    return registrationBean;
}
```

> 🔸 스프링 부트는 `DelegatingFilterProxy`를 통해 Spring Security 같은 필터를 자동 등록한다.  
> 🔸 필터 자체는 스프링 빈과 무관한 서블릿 표준 컴포넌트이므로, 의존성 주입(DI)이 직접 되지 않는다.

---

<br/>

## 2️⃣ Interceptor (스프링 MVC 수문장)

### 개념
`Interceptor`는 스프링 MVC의 `DispatcherServlet` 이후에 동작하며,  
컨트롤러 접근 전후 및 뷰 렌더링 이후까지 세밀하게 제어할 수 있다.

---

### 인터셉터의 흐름

> HTTP Request → WAS → Filter → Servlet → Spring Interceptor → Controller

---

### 제한 예시
```text
HTTP Request → WAS → Filter → Servlet → Spring Interceptor → Controller (로그인 사용자)  
HTTP Request → WAS → Filter → Servlet → Spring Interceptor (적절하지 않은 요청 → 컨트롤러 호출X - 비 로그인 사용자)
```

---

### 🔗 인터셉터 체인
> HTTP 요청 → WAS → Filter → Servlet → Interceptor1 → Interceptor2 → Controller

---

### `HandlerInterceptor` 인터페이스
```java
public interface HandlerInterceptor {
    default boolean preHandle(HttpServletRequest request,
                              HttpServletResponse response,
                              Object handler) throws Exception {
        return true;
    }

    default void postHandle(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler,
                            @Nullable ModelAndView modelAndView) throws Exception {}

    default void afterCompletion(HttpServletRequest request,
                                 HttpServletResponse response,
                                 Object handler,
                                 @Nullable Exception ex) throws Exception {}
}
```
- `preHandle()` : 컨트롤러 호출 전 (false 반환 시 요청 중단)
- `postHandle()` : 컨트롤러 호출 후, 뷰 렌더링 전
- `afterCompletion()` : 뷰 렌더링 후 (예외 발생 시에도 호출)

---

### 주요 용도
- 로그인/권한 검증 (JWT, 세션 등)
- 컨트롤러 공통 처리 (로그 추적, 응답 가공)
- API 요청 시간 측정

### 등록 방법
`WebMvcConfigurer`를 구현하여 URL 패턴별로 세밀히 제어 가능하다.
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new AuthInterceptor())
                .addPathPatterns("/api/**")
                .excludePathPatterns("/api/login", "/api/signup");
    }
}
```

---

<br/>

## 3️⃣ Filter vs Interceptor vs AOP
| 구분          | Filter                              | Interceptor                 | AOP                  |
| ----------- | ----------------------------------- | --------------------------- | -------------------- |
| 동작 시점       | WAS 단계 (서블릿 전)                      | 스프링 MVC 단계 (Controller 전/후) | 스프링 빈 메서드 호출 시       |
| 기반 기술       | Servlet API                         | Spring MVC                  | Spring AOP (프록시 기반)  |
| 등록 위치       | `web.xml`, `FilterRegistrationBean` | `WebMvcConfigurer`          | `@Aspect`, `@Around` |
| 적용 대상       | 모든 요청 (정적 리소스 포함)                   | 스프링 컨트롤러 핸들러                | 스프링 빈의 메서드            |
| DI 사용 가능 여부 | ❌ (스프링 빈 아님)                        | ✅ (스프링 빈)                   | ✅ (스프링 빈)            |
| 대표 사용 예시    | 인코딩, CORS, XSS, 로깅 , 인증/인가                 | 인증/인가, 요청 검증                | 트랜잭션, 예외처리       |

---

## ✅ 마무리 정리
- `Filter` : WAS 레벨의 요청 전처리 (스프링 독립)
- `Interceptor` : MVC 요청 제어 (스프링 의존)
- `AOP` : 비즈니스 로직 공통관심사 (트랜잭션, 로깅 등)

### 결론:
- 정답은 없다.
- 시스템 구조에 따라 필터 + 인터셉터를 병행하거나, Spring Security의 FilterChainProxy 내부에서 처리하기도 한다.
- 다만 "전역 처리 = Filter", "비즈니스 요청 단위 처리 = Interceptor" 가 일반적이다.
