# 🧩 JWT (JSON Web Token)

## 1. JWT란?

JWT(JSON Web Token)는 **JSON 형식의 정보를 안전하게 전송하기 위한 자체 포함형 토큰**입니다.  
인증(Authentication)과 인가(Authorization) 과정에서 자주 사용되며, 서버가 세션을 직접 저장하지 않아도 **Stateless 인증**을 구현할 수 있습니다.

> 💡 즉, 사용자의 로그인 정보를 토큰 안에 직접 담아 서버 간 상태 저장 없이 인증을 수행합니다.

---

## 2. 세션(Session) / 쿠키(Cookie)와의 차이

| 방식 | 설명 | 저장 위치 | 특징 |
|------|------|------------|------|
| **Cookie** | 서버가 클라이언트에 전달하는 작은 키/값 데이터 | 클라이언트(브라우저) | 요청마다 자동 전송되며 보안에 취약할 수 있음 |
| **Session** | 서버에 사용자 상태를 저장하고, 브라우저는 세션 ID만 쿠키로 보관 | 서버 | 서버 부하 증가, Stateful |
| **JWT** | 사용자 정보와 만료 시간 등을 직접 포함하는 자체 포함형 토큰 | 클라이언트 | 서버에 상태 저장 X, Stateless 인증 가능 |

---

## 3. JWT의 사용 이유 & 방법

### ✅ 사용 이유
- 서버 부하 감소 (세션 저장소 불필요)
- 분산 환경(멀티 서버)에서도 인증 상태 유지 용이
- RESTful API에 적합한 Stateless 구조

### ⚙️ 동작 흐름
1. **로그인 시 인증 성공 → JWT 발급**
2. 클라이언트는 JWT를 **HTTP 헤더(Authorization: Bearer)** 에 포함하여 요청
3. 서버는 전달된 JWT를 검증해 사용자 인증/인가 처리

### JWT 구성 요소

| 구성 요소 | 내용 |
|------------|------|
| **Header** | 토큰 유형(`typ`: JWT), 서명 알고리즘(`alg`: HS256 등) |
| **Payload** | 실제 데이터(`sub`, `iat`, `exp`, `role` 등 Claims) |
| **Signature** | Header + Payload + 비밀키로 생성된 서명 (무결성 검증용) |

---

## 4. JWT의 문제점과 해결법

| 문제점 | 원인 | 해결책 |
|--------|------|--------|
| **토큰 탈취 위험** | 클라이언트 저장소(LocalStorage 등) 노출 | `HttpOnly`, `Secure`, `SameSite` 쿠키 사용 |
| **만료 후 인증 불가** | Access Token이 만료됨 | `Refresh Token`으로 재발급 구조 도입 |
| **서버 무효화 불가능** | Stateless 구조상 즉시 폐기 어려움 | **Blacklist**로 강제 만료 처리 |
| **토큰 크기 증가** | Claim이 많을 경우 | 필요한 최소 정보만 담기 |

---

## 5. AccessToken / RefreshToken 구조

| 구분 | 설명 | 유효 기간 | 역할 |
|------|------|------------|------|
| **Access Token** | API 요청 시 매번 함께 전송되어 사용자 인증에 사용 | 짧음 (예: 15분~1시간) | 빠른 인증 수행, 유출 시 피해 최소화 |
| **Refresh Token** | Access Token 재발급용 | 김 (예: 2주~1개월) | Access Token 갱신 및 재인증 역할 |

> ⚙️ **흐름 요약**
> 1. 로그인 성공 → Access Token + Refresh Token 발급  
> 2. Access Token 만료 시 → Refresh Token으로 새로운 Access Token 발급  
> 3. Refresh Token도 만료 시 → 재로그인 필요

---

## 6. 화이트리스트(Whitelist) / 블랙리스트(Blacklist)

| 구분 | 개념 | 주요 사용 대상 | 목적 |
|------|------|----------------|------|
| **Whitelist** | 서버가 **유효한 토큰만 저장·관리**하는 방식 | 주로 `Refresh Token` | 유효한 리프레시 토큰만 DB나 Redis에 보관하여 재발급 요청 시 검증 |
| **Blacklist** | 서버가 **만료되거나 강제 무효화된 토큰을 저장**하는 방식 | 주로 `Access Token` | 로그아웃 시점 등에서 더 이상 유효하지 않은 토큰을 등록해 차단 |

### ✅ 활용 방식
- **Access Token → Blacklist 등록**  
  → 로그아웃 시, 해당 Access Token을 블랙리스트에 저장하여 재사용 방지  
- **Refresh Token → Whitelist 검증**  
  → Refresh Token이 DB/Redis에 존재해야만 새로운 Access Token 재발급 가능  

> 💡 즉, **Whitelist**는 “살아 있는 토큰 목록”,  
> **Blacklist**는 “죽은 토큰 목록”으로 이해하면 된다.

---

## 정리

> JWT는 **서버가 세션을 저장하지 않아도 인증 상태를 유지할 수 있는 자체 포함형 토큰**으로,  
> 일반적으로 **Access Token은 짧게**, **Refresh Token은 길게** 유지하며,  
> 보안을 위해 `HttpOnly`, `Secure`, `SameSite` 쿠키 속성과  
> **Whitelist(유효 토큰 관리)**, **Blacklist(무효 토큰 차단)** 전략을 함께 사용한다.
