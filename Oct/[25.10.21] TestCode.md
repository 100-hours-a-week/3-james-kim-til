# TIL: Spring Boot 테스트 코드 기본 정리

> 오늘은 **Spring Boot 환경에서 테스트 코드의 개념과 작성 흐름**을 정리했습니다.  
> 실제 프로젝트에서는 **“모든 코드를 테스트하기보단, 의미 있는 핵심 로직을 단위 테스트로 검증”** 하는 것이 효율적입니다.

---

## 1️⃣ 테스트 코드란?

> 프로그램의 기능이 의도대로 동작하는지를 자동으로 검증하기 위해 작성하는 코드

### 왜 필요한가?
- 코드 수정·리팩토링 시 **사이드 이펙트(부작용)** 최소화  
- **서비스 안정성** 확보 및 **협업 효율성** 향상  
- 사람이 직접 검증할 필요 없이 **자동 검증 가능**

### 특징
- 빠르고 반복 가능한 검증 수단
- 버그를 조기 발견
- 기능 단위로 독립적 실행 가능 (FIRST 원칙)

<br/>

---

## 2️⃣ 테스트 코드의 기본 원칙 — **FIRST**

> 좋은 테스트 코드는 아래의 다섯 가지 원칙을 만족해야 합니다.

| 항목 | 의미 | 설명 |
|------|------|------|
| **F - Fast** | 빠르게 | 테스트는 단위가 작고 DB나 서버 의존이 없어야 함 |
| **I - Independent** | 독립적 | 각 테스트는 순서나 다른 테스트에 영향받지 않아야 함 |
| **R - Repeatable** | 반복 가능 | 어디서나 같은 결과를 내야 함 |
| **S - Self-validating** | 자체 검증 가능 | 사람이 확인하지 않아도 통과/실패 여부를 자동 판단 |
| **T - Thorough & Timely** | 충분하고 시기 적절하게 | 가능한 많은 케이스를, 개발 초기에 작성 |

➡️ 따라서 실제 개발에서는 “작고 독립적인 단위 테스트”를 우선 작성하고,  
필요 시 통합 테스트로 확장하는 것이 일반적입니다.

<br/>

---

## 3️⃣ TDD (Test Driven Development)

> **“테스트가 개발을 이끈다.”**  
> 코드를 작성하기 전에 테스트를 먼저 작성하고, 그 테스트를 통과하는 코드를 구현하는 개발 방식

### 🔄 절차
1. 실패하는 테스트 작성 (Red)
2. 테스트를 통과하는 최소한의 코드 작성 (Green)
3. 코드 리팩토링 (Refactor)

### 장점
- 코드의 정확성과 유지보수성 향상  
- 개발자가 로직을 명확히 이해하게 됨  
- 자연스럽게 모듈화된 구조 형성

<br/>

---

## 4️⃣ BDD (Behavior Driven Development)

> **“사용자 행동 중심의 테스트”**  
> 사용자의 **행동(Behavior)** 관점에서 시스템이 어떻게 작동해야 하는지를 정의하는 방식

### 특징
- 시나리오 기반 (`Given - When - Then`)  
- 기획자·QA·개발자 간 **커뮤니케이션 용이**
- TDD보다 **요구사항 중심**

### 예시
```java
@Test
@DisplayName("계산기를 이용해 1에 1을 더하면 2가 나온다.")
void plusTest() {
    // Given
    Calculator calculator = new Calculator();

    // When
    int result = calculator.plus(1, 1);

    // Then
    assertThat(result).isEqualTo(2);
}
```

<br/>

---

## 5️⃣ JUnit5 + Mockito 단위 테스트

> 하나의 기능(메서드, 클래스)이 의도대로 동작하는지를 독립적으로 검증

### 기본 예시
```java
@Test
void addTest() {
    // given
    int a = 10;
    int b = 5;

    // when
    int result = calculator.add(a, b);

    // then
    assertThat(result).isEqualTo(15);
}
```

### Mockito와 함께 쓰기
- `@Mock` : 가짜 객체 생성
- `@InjectMocks` : 테스트 대상 클래스에 Mock 객체 주입
- `given()` / `when()` / `thenReturn()` : 동작 예측 및 반환값 설정
- `verify()` : 호출 검증

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    void 유저_가입_성공() {
        // given
        SignUpRequestDto request = new SignUpRequestDto("test@example.com", "Password1234!", "kim");
        given(userRepository.existsByEmail(request.getEmail())).willReturn(false);

        // when
        userService.signUp(request);

        // then
        verify(userRepository, times(1)).save(any());
    }
}
```

<br/>

---

## 6️⃣ 통합 테스트(@SpringBootTest)

> 실제 애플리케이션 구동 환경과 유사하게, 여러 계층이 함께 동작하는 테스트

- `@SpringBootTest`: 스프링 컨텍스트 전체 로드
- DB, Service, Controller 등 실제 빈을 주입받아 테스트
- 속도는 느리지만, 전체 흐름 검증용으로 중요

### 예시
```java
@SpringBootTest
class UserIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void 회원가입_API_테스트() throws Exception {
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"email\": \"test@example.com\", \"password\": \"1234\"}"))
                .andExpect(status().isOk());
    }
}
```

<br/>

---

## 7️⃣ 정리

| 구분    | 단위 테스트         | 통합 테스트          |
| ----- | -------------- | --------------- |
| 목적    | 개별 기능 검증       | 전체 시스템 흐름 검증    |
| 속도    | 빠름             | 느림              |
| 실행 범위 | 한 클래스/메서드      | 여러 모듈           |
| 의존성   | 없음 (Mock 활용)   | 실제 Bean, DB 연동  |
| 예시    | Service, Logic | API, Repository |

- Service 레이어 중심으로 단위 테스트 작성
- Repository / Controller 는 필요 시 보조적으로
- 모든 코드를 테스트할 필요 없음 — “가치 있는 로직”만 테스트
- ⚠️ 실패 시나리오 테스트가 특히 중요

결론적으로, 단위 테스트 → 통합 테스트 순서로 진행하며  
단위 테스트조차도 의미 있는 핵심 기능 위주로 작성하는 것이 가장 효율적입니다.
